#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <string.h>

#define SIZE 4096
#define MAX 100

//Global Function used to handel graceful shutdowns
void sigHandler (int);

//The almighty struct used to store all data stored in shared memory
struct sharedMemory{

    int running;
    int flag;
    int turn;
    char input[MAX];

} ;

//The almighty shared memory pointer that will point to the address
//of the shared memory
struct sharedMemory *shmPtr ;

//struct used to obtain shared memory info
struct shmid_ds buf;

//variable used to keep track of number of reader programs currently running
int numReaders;

int main()
{
    //variable will hold the token/key generated by ftok
    key_t key;
    
    //variable will be used to get a specific region of memory to use a shared memory
    int shmId;
   
    //default pathname used to generate ftok key
    char *pathname = "/tmp";

    //Initialize the shared memory accordingly
    struct sharedMemory sm = {1, 0,0, " "};
    
    //Generates an IPC key, both programs need identical key
    key = ftok(pathname, 4);
    if(key == -1){
    printf("ftok failed with errno = %d\n", errno);
    return -1;
    }

    //Get's a specified region for shared memory and grants necessary permissions 
    //for the specific program
    if ( (shmId = shmget(key, sizeof(struct sharedMemory)*MAX, IPC_CREAT|S_IRUSR|S_IWUSR)) < 0) {
        perror("Error creating shared memory.\n");
        exit(1);
    }

    //Attaches the specified region of shared memory to the address
    //space of the calling process
    if ( (shmPtr = (struct sharedMemory *)shmat(shmId, 0, 0)) == (void*) -1) {
        perror("Can't attach shared memory to address.\n");
        exit(1);
    }

    //super important line of code, moves the local sharedMemory object
    //"sm" to the address that the shmPtr is pointing to. 
    memcpy(&shmPtr[0], &sm, sizeof(struct sharedMemory));
    //Handle Graceful Shutdowns Accordingly
    signal(SIGINT, sigHandler);
    
    printf("Writer Program Starting...\n");
    
    //loop keeps the program live/running
    while(shmPtr[0].running  == 1){
       
    //Busy wait for writer to sit until both reader programs have read the input  
    while(shmPtr[0].flag != 0); 

    //update struct with new user input
    fgets(shmPtr[0].input, MAX, stdin);

    //Breaks loop if CTRL-C'ed
    if(shmPtr[0].running == 0){
    break;
    }

    //printf("%s\n", shmPtr[0].input);
    
    //set flag back to number of readers currently running,
    //allowing the reader programs to break their busy waits
    //and read the new input
    numReaders = shmctl(shmId, IPC_STAT, &buf);
    shmPtr[0].flag = ((int) buf.shm_nattch - 1);
    }

    //Detaches the shared memory region upon shutting down
    if (shmdt (shmPtr) < 0) { 
    perror ("just can't let go\n"); 
    exit (1); 
    } 

    //free's the shared space used by the program
    if (shmctl (shmId, IPC_RMID, 0) < 0) { 
      perror ("can't deallocate\n"); 
      exit(1); 
    }
    return 0;
}

//Handle signal interrupts
void sigHandler (int sigNum){
    if(sigNum == SIGINT){
        shmPtr[0].running = 0;
	shmPtr[0].flag = ((int) buf.shm_nattch - 1);
    }
}
